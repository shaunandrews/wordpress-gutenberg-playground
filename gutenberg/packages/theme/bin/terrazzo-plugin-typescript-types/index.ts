import assert from 'node:assert';
import { type Plugin } from '@terrazzo/parser';

interface TypePattern {
	/**
	 * Regular expression with capture group to extract values from token IDs.
	 */
	pattern: RegExp;

	/**
	 * Optional transformer function to modify captured values.
	 */
	transform?: ( value: string ) => string;
}

interface TypeDefinition {
	/**
	 * Name of the TypeScript type to generate.
	 */
	name: string;

	/**
	 * Description for JSDoc comment.
	 */
	description: string;

	/**
	 * Patterns to extract values from. Can be a RegExp, or an object with a
	 * pattern and optional transform function.
	 */
	patterns: Array< RegExp | TypePattern >;
}

interface TypeScriptTypesOptions {
	/**
	 * Output filename for the generated TypeScript types.
	 */
	filename?: string;

	/**
	 * Type definitions to generate.
	 */
	types?: TypeDefinition[];
}

/**
 * Generates TypeScript types from design tokens based on configurable patterns.
 *
 * @param options          The options for the plugin.
 * @param options.filename Output filename for the generated types.
 * @param options.types    Type definitions to generate.
 */
export default function typescriptTypes( {
	filename = 'ts/token-types.ts',
	types = [],
}: TypeScriptTypesOptions = {} ): Plugin {
	assert( filename, 'filename is required' );

	/**
	 * Mapping of type name to set of extracted values.
	 */
	const typeValues = new Map< string, Set< string > >(
		types.map( ( typeDef ) => [ typeDef.name, new Set() ] )
	);

	/**
	 * Returns true if a token is a primitive token, or false otherwise.
	 *
	 * @param id Token ID
	 * @return Whether the given token is a primitive token.
	 */
	const isPrimitive = ( id: string ) => id.includes( '.primitive.' );

	return {
		name: '@wordpress/terrazzo-plugin-typescript-types',
		async transform( { tokens } ) {
			for ( const id of Object.keys( tokens ) ) {
				if ( isPrimitive( id ) ) {
					continue;
				}

				for ( const typeDef of types ) {
					const values = typeValues.get( typeDef.name )!;

					for ( const item of typeDef.patterns ) {
						const pattern =
							item instanceof RegExp ? item : item.pattern;
						const transform =
							item instanceof RegExp ? undefined : item.transform;

						let value = pattern.exec( id )?.[ 1 ];
						if ( value ) {
							if ( transform ) {
								value = transform( value );
							}

							values.add( value );
						}
					}
				}
			}
		},
		async build( { outputFile } ) {
			const outputLines = [
				'/**',
				' * This file is generated by the @wordpress/terrazzo-plugin-typescript-types plugin.',
				' * Do not edit this file directly.',
				' */',
				'',
			];

			for ( const typeDef of types ) {
				const values = typeValues.get( typeDef.name )!;
				assert(
					values.size,
					`There were no matched values for the type ${ typeDef.name }. ` +
						'This is almost certainly an error, and the pattern should be updated or removed.'
				);

				const unionType = Array.from( values )
					.map( ( value ) => JSON.stringify( value ) )
					.join( ' | ' );

				outputLines.push(
					'/**',
					` * ${ typeDef.description }`,
					' */',
					`export type ${ typeDef.name } = ${ unionType };`,
					''
				);
			}

			outputFile( filename, outputLines.join( '\n' ) );
		},
	};
}
